var common = require('common');
var crypto = require('crypto');
var websock = require('websock');
var parseURL = require('url').parse;
var createRouter = require('router').create;

var noop = function() {};

var PING_INTERVAL = 60*1000;

var JSONSocket = common.emitter(function(socket, open) {
	var self = this;
	
	this.socket = socket;
	this.buffer = [];
	
	if (open) {
		this.send = this._send;
	} else {
		socket.on('open', function() {
			self.send = self._send;
			while (self.buffer.length) {
				self._send(self.buffer.shift());
			}
			self.emit('open');
		});
	}
	
	var destroy = function() {
		socket.destroy();
	};
	var onclose = common.once(function() {
		self.onclose(); // internal signaling
		self.emit('close');
	});	
	
	socket.on('message', function(message) {
		if (message === 'ping') {
			self.socket.send('pong');
			return;
		}
		if (message === 'pong') {
			return;
		}
		self.emit('message', JSON.parse(message));
	});
	socket.on('close', onclose);
});

JSONSocket.prototype.send = function(data) {
	this.buffer.push(data);
};
JSONSocket.prototype.end = function() {
	this.socket.end();
};
JSONSocket.prototype.destroy = function() {
	this.socket.destroy();
};
JSONSocket.prototype.ping = function() {
	var ping = setInterval(this.socket.send.bind(this.socket, 'ping'), PING_INTERVAL);

	this.onclose = function() {
		clearInterval(ping);
	};
};
JSONSocket.prototype.onclose = noop;

JSONSocket.prototype._send = function(data) {
	this.socket.send(JSON.stringify(data));
};

exports.connect = function(host) {
	var socket = websock.connect(host);

	socket = new JSONSocket(socket);
	socket.ping();
	
	return socket;
};

// Browser interface

var TIMEOUT = 15000;

var LongPoll = common.emitter(function() {
	this._chunk = '';
	this._buffer = [];
	this._reader = this._pusher;
	this._destroyed = false;
	this._timeout = setTimeout(this.destroy.bind(this), TIMEOUT);
});

LongPoll.prototype.send = function(message) {
	this._reader(null, JSON.stringify(message));
};
LongPoll.prototype.destroy = function() {
	if (this._destroyed) {
		return;
	}
	clearTimeout(this._timeout);
	
	this._destroyed = true;
	this._reader(new Error('socket destroyed'));
	this.emit('close');
};

LongPoll.prototype.read = function(fn) {
	var self = this;
	var buffer = this._buffer;

	if (buffer.length) {		
		this._buffer = [];
		fn(null, buffer.join('\n')+'\n');
		return;
	}
	
	clearTimeout(this._timeout);
	
	this._reader = function(err, data) {
		self._timeout = setTimeout(self.destroy.bind(self), TIMEOUT);
		self._reader = self._pusher;
		fn(err, data);
	};
};
LongPoll.prototype.write = function(messages) {
	var self = this;
	
	messages = (this._chunk + messages).split('\n');

	this._chunk = messages.pop();
	
	messages.forEach(function(message) {
		if (message === 'ping') {
			self._reader(null, 'pong');
			return;
		}
		message = JSON.parse(message);
		self.emit('message', message);
	});
};

LongPoll.prototype._pusher = function(err, data) {
	if (err) {
		return;
	}
	this._buffer.push(data);
};

exports.listen = function(router, onsocket, callback) {
	if (typeof router === 'number' || typeof router === 'string') {
		var port = router;
		
		router = exports.listen(createRouter(), onsocket);
		router.listen(port, callback || noop);
		
		return router;
	}
	var polls = {};

	router = createRouter(router);
	
	router.upgrade(websock.onupgrade(function(connection) {
		onsocket(new JSONSocket(connection, true));
	}));

	var responder = function(query, response) {
		if (query.callback) {
			return function(status, data) {
				response.writeHead(200, {'content-type':'application/javascript; charset=utf=8'});
				response.end(query.callback+'('+JSON.stringify(data)+');');
			};
		}
		return function(status, data) {
			response.writeHead(status, {'access-control-allow-origin':'*', 'content-type':'text/plain; charset=utf-8'});
			response.end(data);
		};
	};

	router.get('/json-sockets/create', function(request, response) {
		var query = parseURL(request.url, true).query;
		var id = Math.random().toFixed(20).substring(2);	
		var lp = polls[id] = new LongPoll();
		var respond = responder(query, response);

		lp.on('close', function() {
			delete polls[id];
		});

		onsocket(lp);

		respond(200, id);
	});

	router.get('/json-sockets/read', function(request, response) {
		var query = parseURL(request.url, true).query;
		var socket = polls[query.id];

		var respond = responder(query, response);
		var onerror = function() {
			respond(404, '');
		};

		if (!socket) {
			onerror();
			return;
		}

		request.on('close', function() {
			socket.destroy();
		});

		socket.read(common.fork(onerror, function(data) {
			respond(200, data);
		}));
	});

	router.get('/json-sockets/write', function(request, response) {
		var query = parseURL(request.url, true).query;
		var respond = responder(query, response);
		var socket = polls[query.id];
		
		if (!socket) {
			respond(404, '');
			return;
		}
		
		socket.write(query.post);
		respond(200, 'ack');
	});
	router.post('/json-sockets/write', function(request, response) {
		var query = parseURL(request.url, true).query;
		var socket = polls[query.id];

		var onerror = function() {
			request.connection.destroy();
		};

		if (!socket) {
			onerror();
			return;
		}
		var buf = '';

		request.setEncoding('utf-8');
		request.on('data', function(data) {
			buf += data;
		});
		request.on('end', function() {
			if (polls[query.id]) {
				socket.write(buf);			
			}
			response.writeHead(200, {'access-control-allow-origin':'*', 'content-type':'text/plain'});
			response.end('ack');		
		});
	});
	
	return router;
};